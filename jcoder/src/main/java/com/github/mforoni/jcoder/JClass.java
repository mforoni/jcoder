package com.github.mforoni.jcoder;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;
import javax.lang.model.element.Modifier;
import org.supercsv.cellprocessor.ift.CellProcessor;
import com.github.mforoni.jbasic.JStrings;
import com.github.mforoni.jbasic.reflect.JMethods;
import com.github.mforoni.jcoder.ControlFlow.If;
import com.github.mforoni.jcoder.JHeader.Origin;
import com.google.common.base.Function;
import com.google.common.base.Joiner;
import com.google.common.base.Optional;
import com.google.common.collect.Collections2;
import com.google.common.collect.Lists;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

/**
 * Based on JavaPoet API.
 * 
 * @author Foroni
 */
@Immutable
public final class JClass {
  static final Modifier[] PUBLIC_STATIC_FINAL = {Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL};
  static final Modifier[] PRIVATE_STATIC_FINAL =
      {Modifier.PRIVATE, Modifier.STATIC, Modifier.FINAL};
  private static final String AUTO_GENERATED = "Auto generated";
  private static final String AUTO_GENERATED_FROM_FILE = "Auto generated from file %s";
  private final String name;
  private final String packageName;
  private final List<JField> fields;

  public JClass(final String name, final String packageName, final List<JField> fields) {
    this.name = name;
    this.packageName = packageName;
    this.fields = fields;
  }

  /**
   * Returns the class name.
   * 
   * @return the class name
   */
  public String getName() {
    return name;
  }

  public String getPackageName() {
    return packageName;
  }

  public List<JField> getFields() {
    return fields;
  }

  @Override
  public String toString() {
    return "JClass [name=" + name + ", packageName=" + packageName + ", fields=" + fields + "]";
  }

  public static class Builder {
    private final String className;
    private final String packageName;
    private final List<JField> fields;

    public Builder(final String className, final String packageName) {
      this.className = className;
      this.packageName = packageName;
      fields = new ArrayList<>();
    }

    public Builder field(final String name, final Class<?> type) {
      return field(name, type, false);
    }

    public Builder field(final String name, final Class<?> type, final boolean nullable) {
      fields.add(new JField(name, type, nullable));
      return this;
    }

    public JClass build() {
      return new JClass(className, packageName, fields);
    }

    @Override
    public String toString() {
      return "Builder [className=" + className + ", packageName=" + packageName + ", fields="
          + fields + "]";
    }
  }
  private enum Type {
    BEAN, IMMUTABLE
  }

  public JavaFile buildBean(final Optional<Origin> origin) {
    final TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC)
        .addSuperinterface(Serializable.class).addJavadoc(autoGeneratedOrigin(origin));
    if (origin.isPresent()) {
      switch (origin.get().getType()) {
        case CSV:
          typeBuilder.addField(cellProcessor(fields));
          break;
        case SPREADSHEET:
          final ClassName generatedClassName = getGeneratedClassName(packageName, name);
          typeBuilder.addField(functionField(generatedClassName, origin.get()));
          typeBuilder.addMethod(parseRow(fields, generatedClassName, Type.BEAN, origin.get()));
      }
    }
    typeBuilder.addFields(Lists.transform(fields, JField.TO_PRIVATE_FIELDSPEC));
    typeBuilder.addMethod(noArgsConstructor());
    addGetterAndSetter(typeBuilder, fields);
    typeBuilder.addMethod(toStringMethod(this));
    return JavaFile.builder(packageName, typeBuilder.build()).indent("\t").build();
  }

  public JavaFile buildImmutableClass() {
    return buildImmutableClass(Optional.<Origin>absent());
  }

  public JavaFile buildImmutableClass(final Optional<Origin> origin) {
    final TypeSpec.Builder typeBuilder =
        TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC, Modifier.FINAL)
            .addAnnotation(Immutable.class).addJavadoc(autoGeneratedOrigin(origin));
    if (origin.isPresent()) {
      switch (origin.get().getType()) {
        case CSV:
          typeBuilder.addField(cellProcessor(fields));
          break;
        case SPREADSHEET:
          final ClassName generatedClassName = getGeneratedClassName(packageName, name);
          typeBuilder.addField(functionField(generatedClassName, origin.get()));
          typeBuilder.addMethod(parseRow(fields, generatedClassName, Type.IMMUTABLE, origin.get()));
          break;
      }
    }
    typeBuilder.addFields(Lists.transform(fields, JField.TO_PRIVATE_FINAL_FIELDSPEC));
    typeBuilder.addMethod(constructor(fields));
    typeBuilder.addMethods(Lists.transform(fields, JField.TO_GETTER_METHODSPEC));
    typeBuilder.addMethod(toStringMethod(this));
    return JavaFile.builder(packageName, typeBuilder.build()).indent("\t").build();
  }

  public JavaFile buildHeaderClass(final Optional<Origin> origin) {
    final TypeSpec.Builder typeBuilder = TypeSpec.classBuilder(name).addModifiers(Modifier.PUBLIC)
        .addJavadoc(autoGeneratedOrigin(origin));
    for (final JField field : fields) {
      typeBuilder.addField(JField.constantStringField(field.getName()));
    }
    final Collection<String> constants =
        Lists.transform(fields, JField.TO_CONVENTIONAL_CONSTANT_NAME);
    final FieldSpec header = FieldSpec.builder(String[].class, "HEADER", PUBLIC_STATIC_FINAL)
        .initializer("{" + Joiner.on(", ").join(constants) + "}").build();
    typeBuilder.addField(header);
    return JavaFile.builder(packageName, typeBuilder.build()).indent("\t").build();
  }

  private static FieldSpec functionField(final ClassName generatedClassName, final Origin origin) {
    final String argName = "row";
    final TypeName sourceType = origin.getParserType().toTypeName();
    final ParameterizedTypeName functionType =
        ParameterizedTypeName.get(ClassName.get(Function.class), sourceType, generatedClassName);
    final TypeSpec anonymusClass =
        TypeSpec.anonymousClassBuilder("").addSuperinterface(functionType)
            .addMethod(MethodSpec.methodBuilder("apply").addAnnotation(Override.class)
                .addAnnotation(Nullable.class).addModifiers(Modifier.PUBLIC)
                .addParameter(origin.getParserType().toArrayType(), argName, Modifier.FINAL)
                .addStatement("return $N == null ? null : parseRow($N)", argName, argName)
                .returns(generatedClassName).build())
            .build();
    return FieldSpec.builder(functionType,
        "ROW_TO_".concat(generatedClassName.simpleName().toUpperCase()), JClass.PUBLIC_STATIC_FINAL)
        .initializer(CodeBlock.of("$L", anonymusClass)).build();
  }

  private static String autoGeneratedOrigin(final Optional<Origin> origin) {
    return origin.isPresent() ? String.format(AUTO_GENERATED_FROM_FILE, origin.get().getFilepath())
        : AUTO_GENERATED;
  }

  private static void addGetterAndSetter(final TypeSpec.Builder typeBuilder,
      final Collection<JField> fields) {
    for (final JField field : fields) {
      typeBuilder.addMethod(field.toGetter());
      typeBuilder.addMethod(field.toSetter());
    }
  }

  private static ClassName getGeneratedClassName(final String packageName,
      final String simpleName) {
    return ClassName.get(packageName, simpleName);
  }

  private static MethodSpec parseRow(final List<JField> fields, final ClassName generatedClassName,
      final Type type, final Origin origin) {
    final CodeBlock codeBlock;
    final String varRow = "row";
    final String varObj = "obj";
    final String varI = "i";
    switch (type) {
      case IMMUTABLE:
        // FIXME
        throw new IllegalStateException("TODO");
      case BEAN:
        final String varName = generatedClassName.simpleName().toLowerCase();
        final CodeBlock.Builder codeBuilder = CodeBlock.builder().addStatement(
            "final $T $N = new $T()", generatedClassName, varName, generatedClassName);
        final ControlFlow.Switch switchFlow = ControlFlow.switchBuilder(varI);
        for (int i = 0; i < fields.size(); i++) {
          final JField field = fields.get(i);
          switch (origin.getParserType()) {
            case OBJECTS:
              switchFlow.addCase(i, "%s.%s((%s) %s)", varName, JMethods.setterName(field.getName()),
                  field.getType().getSimpleName(), varObj);
              break;
            case STRINGS:
              if (field.getType().equals(String.class)) {
                switchFlow.addCase(i, "%s.%s(%s)", varName, JMethods.setterName(field.getName()),
                    varObj);
              } else if (field.getType().equals(Boolean.class)
                  || field.getType().equals(Integer.class) || field.getType().equals(Long.class)
                  || field.getType().equals(Double.class)) {
                final ControlFlow.If ifcond = new If(String.format("%s != null", varObj)).statement(
                    "%s.%s(%s.valueOf(%s))", varName, JMethods.setterName(field.getName()),
                    field.getType().getSimpleName(), varObj);
                switchFlow.addCase(i, ifcond.build());
              } else if (field.getType().equals(boolean.class)) {
                switchFlow.addCase(i, "%s.%s(Boolean.parseBoolean(%s))", varName,
                    JMethods.setterName(field.getName()), varObj);
              } else if (field.getType().equals(int.class)) {
                switchFlow.addCase(i, "%s.%s(Integer.parseInt(%s))", varName,
                    JMethods.setterName(field.getName()), varObj);
              } else if (field.getType().equals(long.class)) {
                switchFlow.addCase(i, "%s.%s(Long.parseLong(%s))", varName,
                    JMethods.setterName(field.getName()), varObj);
              } else if (field.getType().equals(double.class)) {
                switchFlow.addCase(i, "%s.%s(Double.parseDouble(%s))", varName,
                    JMethods.setterName(field.getName()), varObj);
              } else {
                throw new IllegalStateException("Field type " + field.getType() + " not handled");
              }
              break;
            default:
              throw new AssertionError();
          }
        }
        final ControlFlow.For forFlow = new ControlFlow.For(varI, varRow.concat(".length"));
        final Class<?> objType = origin.getParserType().toType();
        forFlow.statement("final %s %s = %s[%s]", objType.getSimpleName(), varObj, varRow, varI);
        forFlow.statement(switchFlow.build());
        codeBuilder.add(forFlow.build());
        codeBuilder.addStatement("return $N", varName);
        codeBlock = codeBuilder.build();
        break;
      default:
        throw new AssertionError();
    }
    final Class<?> inputType = origin.getParserType().toArrayType();
    return MethodSpec.methodBuilder("parseRow").returns(generatedClassName)
        .addModifiers(Modifier.PUBLIC, Modifier.STATIC).addAnnotation(Nullable.class)
        .addParameter(inputType, varRow, Modifier.FINAL).addCode(codeBlock).build();
  }

  private static FieldSpec cellProcessor(final List<JField> fields) {
    final CodeBlock.Builder initializer = CodeBlock.builder();
    initializer.add("{ //").add(JStrings.NEWLINE);
    for (final JField field : fields) {
      initializer.add(JField.toCellProcessor(field)).add(", // ".concat(field.getName()))
          .add(JStrings.NEWLINE);
    }
    initializer.add("}");
    return FieldSpec.builder(CellProcessor[].class, "CELL_PROCESSOR", PUBLIC_STATIC_FINAL)
        .initializer(initializer.build()).build();
  }

  public static MethodSpec noArgsConstructor() {
    return MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC).build();
  }

  public static MethodSpec constructor(final Collection<JField> fields) {
    final MethodSpec.Builder constructor =
        MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC);
    for (final JField field : fields) {
      constructor.addParameter(field.getType(), field.getName(), Modifier.FINAL);
    }
    for (final JField field : fields) {
      constructor.addStatement("this.$N = $N", field.getName(), field.getName());
    }
    return constructor.build();
  }

  public static MethodSpec toStringMethod(final JClass jclass) {
    return toStringMethod(jclass.getName(), jclass.getFields());
  }

  public static MethodSpec toStringMethod(final String className, final Collection<JField> fields) {
    final Collection<String> names = Collections2.transform(fields, JField.TO_NAME);
    final String statement = new StringBuilder("return String.format(\""). //
        append(className).append(" ["). //
        append(Joiner.on("=%s, ").join(names)).append("=%s]\", "). //
        append(Joiner.on(", ").join(names)).append(")").toString();
    return MethodSpec.methodBuilder("toString").returns(String.class).addModifiers(Modifier.PUBLIC)
        .addAnnotation(Override.class).addStatement(statement).build();
  }
}
